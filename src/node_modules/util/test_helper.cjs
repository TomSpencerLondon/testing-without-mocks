// Copyright Titanium I.T. LLC.
const ensure = require("util/ensure.cjs");
const http = require("http");
const path = require("path");
const childProcess = require("child_process");

/** Perform an HTTP request in a way that's convenient for tests. Deletes certain headers tests don't care about.
 *
 * @param port localhost port
 * @param url path
 * @param method GET, POST, etc.
 * @param headers optional; headers to send
 * @param body optional; body to send
 * @returns { status, headers, body } status, headers, and body returned by server
 */
exports.requestAsync = async function({ port, url, method, headers, body = [] } = {}) {
	return await new Promise((resolve, reject) => {
		ensure.signature(arguments, [[ undefined, {
			port: [ Number, String ],
			url: [ undefined, String ],
			method: [ undefined, String ],
			headers: [ undefined, Object ],
			body: [ undefined, Array ],
		}]]);
		if (method === undefined && body.length !== 0) method = "POST";

		const request = http.request({ port, path: url, method, headers });
		body.forEach((chunk) => request.write(chunk));
		request.end();

		request.on("response", (response) => {
			let body = "";
			response.on("data", (chunk) => {
				body += chunk;
			});
			response.on("error", (err) => reject(err));
			response.on("end", () => {
				const headers = response.headers;
				delete headers.connection;
				delete headers["content-length"];
				delete headers.date;

				resolve({
					status: response.statusCode,
					headers: response.headers,
					body,
				});
			});
		});
	});
};

/** Run specified module in a separate process.
 *
 * @param cwd working directory
 * @param modulePath path to module (relative to working directory)
 * @param args optional; process arguments (default none)
 * @param failOnStderr optional; if true, throws an error if anything is written to stderr (default true)
 * @returns { stdout, stderr } data written to stdout and stderr
 */
exports.runModuleAsync = function(cwd, modulePath, { args = [], failOnStderr = true } = {}) {
	return new Promise((resolve, reject) => {
		ensure.signature(arguments, [ String, String, [ undefined, {
			args: [ undefined, Array ],
			failOnStderr: [ undefined, Boolean ],
		}]], [ "cwd", "modulePath", "options" ]);

		const child = exports.forkModule(cwd, modulePath, { args });

		let stdout = "";
		let stderr = "";
		child.stdout.on("data", (data) => {
			stdout += data;
		});
		child.stderr.on("data", (data) => {
			stderr += data;
		});

		child.on("exit", (code) => {
			if (code !== 0 || (failOnStderr && stderr !== "")) {
				return reject(new Error(`Runner failed.\nstdout: ${stdout}\nstderr: ${stderr}`));
			}
			else {
				return resolve({ stdout, stderr });
			}
		});
	});
};

/** Runs a Node.js module in a separate process.
 *
 * @param cwd working directory
 * @param modulePath path to module (relative to working directory)
 * @param args optional; process arguments (default none)
 * @returns { stdout, stderr } data written to stdout and stderr
 */
exports.forkModule = function(cwd, modulePath, {
	args = []
} = {}) {
	ensure.signature(arguments, [ String, String, [ undefined, {
		args: [ undefined, Array ],
	}]], [ "cwd", "modulePath", "options" ]);

	const absolutePath = path.resolve(cwd, modulePath);
	const options = {
		stdio: "pipe",
	};
	return childProcess.fork(absolutePath, args, options);
};

/** Resolves a promise and ignores any errors it throws.
 *
 * @param promise the promise to ignore
 */
exports.ignorePromiseErrorAsync = async function(promise) {
	try {
		await promise;
	}
	catch (err) {
	}
};