// Copyright Titanium I.T. LLC.
"use strict";

const ensure = require("util/ensure");
const OutputTracker = require("../util/output_tracker");
const EventEmitter = require("events");
const CommandLine = require("./command_line");
const Clock = require("./clock");
const util = require("node:util");

const OUTPUT_EVENT = "output";

/** Logging infrastructure */
const Log = module.exports = class Log {

	static create() {
		ensure.signature(arguments, []);
		return new Log(CommandLine.create(), Clock.create());
	}

	static createNull() {
		ensure.signature(arguments, []);
		return new Log(CommandLine.createNull(), Clock.createNull());
	}

	static get DEBUG() { return "debug"; }

	static get INFO() { return "info"; }

	static get MONITOR() { return "monitor"; }

	static get ACTION() { return "action"; }

	static get EMERGENCY() { return "emergency"; }

	constructor(commandLine, clock, defaults = {}) {
		this._commandLine = commandLine;
		this._clock = clock;
		this._emitter = new EventEmitter();
		this._defaults = defaults;

		this.debug = logFn(this, Log.DEBUG);
		this.info = logFn(this, Log.INFO);
		this.monitor = logFn(this, Log.MONITOR);
		this.action = logFn(this, Log.ACTION);
		this.emergency = logFn(this, Log.EMERGENCY);
	}

	get defaults() {
		return this._defaults;
	}

	bind(defaults) {
		ensure.signature(arguments, [ Object ]);

		const newLog = new Log(this._commandLine, this._clock, { ...this._defaults, ...defaults });
		newLog._emitter = this._emitter;
		return newLog;
	}

	trackOutput() {
		ensure.signature(arguments, []);
		return new OutputTracker(this._emitter, OUTPUT_EVENT);
	}

	equals(other) {
		ensure.signature(arguments, [ Log ]);

		return util.isDeepStrictEqual(this.defaults, other.defaults);
	}

};

function logFn(self, alert) {
	return (data) => {
		doLog(self, alert, data);
	};
}

function doLog(self, alert, data) {
	ensure.signature(arguments, [ Log, String, Object ], [ "self", "alert", "data" ]);

	data = { alert, ...self._defaults, ...data };
	const { dataToLog, dataToTrack } = normalizeErrors(data);

	self._commandLine.writeStdout(`${(currentFormattedTime(self._clock))} ${JSON.stringify(dataToLog)}\n`);
	self._emitter.emit(OUTPUT_EVENT, dataToTrack);
}

function normalizeErrors(data) {
	const dataToLog = {};
	const dataToTrack = {};

	Object.entries(data).forEach(([ name, value ]) => {
		let logValue = value;
		let trackValue = value;
		if (value instanceof Error) {
			logValue = value.stack;
			trackValue = `${value.name}: ${value.message}`;
		}
		dataToLog[name] = logValue;
		dataToTrack[name] = trackValue;
	});

	return { dataToLog, dataToTrack };
}

function currentFormattedTime(clock) {
	const options = {
		dateStyle: "medium",
		timeStyle: "long",
		timeZone: "UTC",
		hourCycle: "h23",
	};
	return clock.toFormattedString(options, "en-US");
}
