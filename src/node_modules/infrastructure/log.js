// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import { OutputListener } from "util/output_listener.js";
import { CommandLine } from "infrastructure/command_line.js";
import { Clock } from "infrastructure/clock.js";

/**
 * Logger. Writes structured logs as JSON to stdout. Provides the ability to set default values which
 * are included in every log output.
 */
export class Log {

	/**
	 * Factory method.
	 * @returns {Log} the instance
	 */
	static create() {
		ensure.signature(arguments, []);
		return new Log(CommandLine.create(), Clock.create());
	}

	/**
	 * Nulled factory method.
	 * @returns {Log} the nulled instance.
	 */
	static createNull() {
		ensure.signature(arguments, []);
		return new Log(CommandLine.createNull(), Clock.createNull());
	}

	/**
	 * @returns {string} 'debug' alert level
	 */
	static get DEBUG() { return "debug"; }

	/**
	 * @returns {string} 'info' alert level
	 */
	static get INFO() { return "info"; }

	/**
	 * @returns {string} 'monitor' alert level
	 */
	static get MONITOR() { return "monitor"; }

	/**
	 * @returns {string} 'action' alert level
	 */
	static get ACTION() { return "action"; }

	/**
	 * @returns {string} 'emergency' alert level
	 */
	static get EMERGENCY() { return "emergency"; }

	/** @deprecated Use a factory method instead. */
	constructor(commandLine, clock, defaults = {}) {
		ensure.signature(arguments, [ CommandLine, Clock, [ undefined, Object ] ]);

		this._commandLine = commandLine;
		this._clock = clock;
		this._listener = new OutputListener();
		this._defaults = defaults;
	}

	/**
	 * @returns {object} the logger's default values (properties that are written with every log)
	 */
	get defaults() {
		return this._defaults;
	}

	/**
	 * Write a log entry with the 'debug' alert level.
	 * @param data the data to write.
	 */
	debug(data) { this.#log(Log.DEBUG, data); }

	/**
	 * Write a log entry with the 'info' alert level.
	 * @param data the data to write.
	 */
	info(data) { this.#log(Log.INFO, data); }

	/**
	 * Write a log entry with the 'monitor' alert level.
	 * @param data the data to write.
	 */
	monitor(data) { this.#log(Log.MONITOR, data); }

	/**
	 * Write a log entry with the 'action' alert level.
	 * @param data the data to write.
	 */
	action(data) { this.#log(Log.ACTION, data); }

	/**
	 * Write a log entry with the 'emergency' alert level.
	 * @param data the data to write.
	 */
	emergency(data) { this.#log(Log.EMERGENCY, data); }

	/**
	 * Create a new logger, based on this one, which has additional default parameters. Existing defaults are
	 * carried over. New defaults override existing defaults with the same name. Output tracking is shared by
	 * both logs.
	 * @param defaults default parameters for the new logger
	 * @returns {Log} the new logger
	 */
	bind(defaults) {
		ensure.signature(arguments, [ Object ]);

		const newLog = new Log(this._commandLine, this._clock, { ...this._defaults, ...defaults });
		newLog._listener = this._listener;
		return newLog;
	}

	/**
	 * Track log output.
	 * @returns {OutputTracker} the output tracker
	 */
	trackOutput() {
		ensure.signature(arguments, []);

		return this._listener.trackOutput();
	}

	#log(alert, data) {
		ensure.signature(arguments, [ String, Object ], [ "alert", "data" ]);

		data = { alert, ...this._defaults, ...data };
		const { dataToLog, dataToTrack } = normalizeErrors(data);

		this._commandLine.writeStdout(`${(currentFormattedTime(this._clock))} ${JSON.stringify(dataToLog)}\n`);
		this._listener.emit(dataToTrack);
	}

}

function normalizeErrors(data) {
	const dataToLog = {};
	const dataToTrack = {};

	Object.entries(data).forEach(([ name, value ]) => {
		let logValue = value;
		let trackValue = value;
		if (value instanceof Error) {
			logValue = value.stack;
			trackValue = `${value.name}: ${value.message}`;
		}
		dataToLog[name] = logValue;
		dataToTrack[name] = trackValue;
	});

	return { dataToLog, dataToTrack };
}

function currentFormattedTime(clock) {
	const options = {
		dateStyle: "medium",
		timeStyle: "long",
		timeZone: "UTC",
		hourCycle: "h23",
	};
	return clock.toFormattedString(options, "en-US");
}
