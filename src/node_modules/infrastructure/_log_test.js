// Copyright Titanium I.T. LLC.
"use strict";

// dependency_analysis: ./_log_test_output_runner
// dependency_analysis: ./_log_test_null_output_runner
const assert = require("util/assert");
const Log = require("./log");
const CommandLine = require("./command_line");
const Clock = require("./clock");
const testHelper = require("util/test_helper");

describe("Log", () => {

	it("writes to stdout", async () => {
		const { stdout } = await testHelper.runModuleAsync(__dirname, "./_log_test_output_runner");
		assert.match(stdout, / UTC {"alert":"info","output":"my output"}\n$/);
	});

	it("outputs current time and structured data", () => {
		const { log, stdout } = createLog();

		const data = {
			output: "my output",
		};
		const expectedData = {
			alert: "info",
			output: "my output",
		};
		log.info(data);
		assert.deepEqual(stdout, [ `Jan 1, 1970, 00:00:00 UTC ${JSON.stringify(expectedData)}\n` ]);
	});

	it("outputs full stack trace for errors", () => {
		const { log, stdout } = createLog();

		const data = {
			output: new Error("my error"),
		};
		log.info(data);
		assert.match(stdout[0], /^Jan 1, 1970, 00:00:00 UTC {"alert":"info","output":"Error: my error\\n    at /);
	});

	it("provides multiple alert levels", () => {
		const { log, output } = createLog();

		log.debug({});
		log.info({});
		log.monitor({});
		log.action({});
		log.emergency({});

		assert.deepEqual(output, [
			{ alert: "debug" },
			{ alert: "info" },
			{ alert: "monitor" },
			{ alert: "action" },
			{ alert: "emergency" },
		]);
	});

	it("can track output", () => {
		const { log } = createLog();
		const output = log.trackOutput();

		const data = {
			output: "my output",
		};
		const expectedOutput = {
			alert: "info",
			output: "my output",
		};

		log.info(data);
		assert.deepEqual(output.data, [ expectedOutput ]);
	});

	it("tracker strips stack traces from errors", () => {
		const { log, output } = createLog();

		const data = {
			output: new Error("my error"),
		};
		const expectedOutput = {
			alert: "info",
			output: "Error: my error",
		};

		log.info(data);
		assert.deepEqual(output, [ expectedOutput ]);
	});


	describe("binding", () => {

		it("can bind defaults that are included in every message", () => {
			const { log, output } = createLog();

			const boundLog = log.bind({ "my-default": "my-value" });
			boundLog.info({ message: "my-message" });

			assert.deepEqual(output, [
				{
					alert: "info",
					"my-default": "my-value",
					message: "my-message",
				},
			]);
		});

		it("reports defaults", () => {
			const { log } = createLog();

			const boundLog = log.bind({ "my-default": "my-value" });
			assert.deepEqual(boundLog.defaults, { "my-default": "my-value" }, "bound log should have defaults");
			assert.deepEqual(log.defaults, {}, "parent log shouldn't have any defaults");
		});

		it("can bind multiple times (and later bindings override earlier bindings)", () => {
			const { log } = createLog();

			const bind1 = log.bind({ binding: "one", bind1: true });
			assert.deepEqual(bind1.defaults, {
				binding: "one",
				bind1: true,
			}, "bind1");

			const bind2 = bind1.bind({ binding: "two", bind2: true });
			assert.deepEqual(bind2.defaults, {
				binding: "two",
				bind1: true,
				bind2: true,
			}, "bind2");

			const bind3 = bind2.bind({ binding: "three", bind3: true });
			assert.deepEqual(bind3.defaults, {
				binding: "three",
				bind1: true,
				bind2: true,
				bind3: true,
			}, "bind3");
		});

		it("all related logs output to the same log tracker, but with different defaults", () => {
			const { log, output } = createLog();

			const bind1 = log.bind({ bind1: true });
			const bind2 = bind1.bind({ bind2: true });

			log.info({ message: "original log" });
			bind1.info({ message: "bind1" });
			bind2.info({ message: "bind2" });

			assert.deepEqual(output, [
				{
					alert: "info",
					message: "original log",
				}, {
					alert: "info",
					bind1: true,
					message: "bind1",
				}, {
					alert: "info",
					bind1: true,
					bind2: true,
					message: "bind2",
				},
			]);
		});

	});


	describe("Nullability", () => {

		it("doesn't write to stdout", async () => {
			const { stdout } = await testHelper.runModuleAsync(__dirname, "./_log_test_null_output_runner");
			assert.equal(stdout, "");
		});

	});

});


function createLog() {
	const commandLine = CommandLine.createNull();
	const stdout = commandLine.trackStdout();
	const clock = Clock.createNull({ now: 0 });
	const log = new Log(commandLine, clock);
	const output = log.trackOutput();
	return { log, stdout, output: output.data };
}
