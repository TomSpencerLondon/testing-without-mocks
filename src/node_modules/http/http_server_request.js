// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import EventEmitter from "node:events";

/** A request from a client to the HTTP server. */
export class HttpServerRequest {

	/**
	 * Factory method. Wraps a Node.js HTTP request.
	 * @param nodeRequest the Node.js HTTP request
	 * @returns {HttpServerRequest} the wrapped request
	 */
	static create(nodeRequest) {
		ensure.signature(arguments, [ Object ]);

		return new HttpServerRequest(nodeRequest);
	}

	/**
	 * Factory method. Simulates an HTTP request.
	 * @param [options] details of the simulated HTTP request
	 * @param [options.url] path and optional querystring
	 * @param [options.method] method (GET, POST, etc.)
	 * @param [options.headers] headers
	 * @param [options.body] body
	 * @returns {HttpServerRequest} the simulated request
	 */
	static createNull(options) {
		// signature checking in StubbedNodeRequest

		return new HttpServerRequest(new StubbedNodeRequest(options));
	}

	/** @deprecated Use a factory method instead. */
	constructor(nodeRequest) {
		ensure.signature(arguments, [ Object ]);

		this._request = nodeRequest;
	}

	/**
	 * @returns {string} URL path (excluding query)
	 */
	get urlPathname() {
		const url = new URL(this._request.url, "http://unused.placeholder.host");
		return decodeURIComponent(url.pathname);
	}

	/**
	 * @returns {string} method (GET, POST, etc.)
	 */
	get method() {
		return this._request.method;
	}

	/**
	 * @returns {object} headers
	 */
	get headers() {
		return { ...this._request.headers };
	}

	/**
	 * Determine whether the request matches a particular content-type header.
	 * @param expectedMediaType the media type to match (e.g., "application/json")
	 * @returns {boolean} true if the content-type header matches the media type
	 */
	hasContentType(expectedMediaType) {
		ensure.signature(arguments, [ String ]);

		const contentType = this.headers["content-type"];
		if (contentType === undefined) return false;

		const [ mediaType, ignoredParameters ] = contentType.split(";");
		return mediaType.trim().toLowerCase() === expectedMediaType.trim().toLowerCase();
	}

	/**
	 * Read the request body. This may only be done once.
	 * @returns {Promise<string>} the body
	 */
	async readBodyAsync() {
		return await new Promise((resolve, reject) => {
			ensure.signature(arguments, []);
			if (this._request.readableEnded) return reject(new Error("Can't read request body because it's already been read"));

			let body = "";
			this._request.on("error", reject);    // this event is not tested
			this._request.on("data", (chunk) => {
				body += chunk;
			});
			this._request.on("end", () => {
				resolve(body);
			});
		});
	}

}


class StubbedNodeRequest extends EventEmitter {

	constructor({
		url = "/null-request-url",
		method = "GET",
		headers = {},
		body = "",
	} = {}) {
		ensure.signature(arguments, [[ undefined, {
			url: [ undefined, String ],
			method: [ undefined, String ],
			headers: [ undefined, Object ],
			body: [ undefined, String ],
		}]]);

		super();
		this.url = url;
		this.method = method.toUpperCase();
		this.headers = normalizeHeaders(headers);
		this._body = body;
		this.readableEnded = false;
	}

	on(event, fn) {
		super.on(event, fn);
		if (event === "end") {
			setImmediate(() => {
				this.emit("data", this._body);
				this.emit("end");
				this.readableEnded = true;
			});
		}
	}

}

function normalizeHeaders(headers) {
	const normalizedEntries = Object.entries(headers).map(([ name, value ]) => [ name.toLowerCase(), value ]);
	return Object.fromEntries(normalizedEntries);
}