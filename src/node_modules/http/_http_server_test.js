// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const ensure = require("util/ensure");
const HttpServer = require("http/http_server");
const testHelper = require("util/test_helper");
const HttpRequest = require("./http_request");
const HttpResponse = require("./http_response");
const Log = require("infrastructure/log");

const PORT = 5001;

describe("HTTP Server", () => {

	describe("starting and stopping", () => {

		it("can start and stop multiple times", async () => {
			const { server } = createServer();
			await startAndStopAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAndStopAsync({ server })
			);
		});

		it("logs server startup", async () => {
			await startAndStopAsync({}, ({ logOutput }) => {
				assert.deepEqual(logOutput.data, [
					{
						alert: "info",
						message: "server started",
						port: PORT,
					},
				]);
			});
		});

		it("says if the server is started", async () => {
			const { server } = createServer();
			assert.equal(server.isStarted, false, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.isStarted, true, "after server started");
			});
			assert.equal(server.isStarted, false, "after server stopped");
		});

		it("says which port the server is on", async () => {
			const { server } = createServer();
			assert.equal(server.port, null, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.port, PORT, "after server started");
			});
			assert.equal(server.port, null, "after server stopped");
		});

		it("provides server log", async () => {
			const log = Log.createNull();

			const { server } = createServer();
			assert.equal(server.log, null, "before server started");
			await startAndStopAsync({ server, log }, () => {
				assert.equal(server.log, log, "after server started");
			});
			assert.equal(server.log, null, "after server stopped");
		});

		it("provides pass-through config", async () => {
			const config = { myConfig: true };

			const { server } = createServer();
			assert.equal(server.config, null, "before server started");
			await startAndStopAsync({ server, config }, () => {
				assert.equal(server.config, config, "after server started");
			});
			assert.equal(server.config, null, "after server stopped");
		});

		it("fails gracefully if server has startup error", async () => {
			const { server: server1 } = createServer();
			const { server: server2 } = createServer();

			await startAndStopAsync({ server: server1 }, async () => {
				await assert.throwsAsync(
					() => startAsync({ server: server2 }),     // fails because another server is already running
					/^Couldn't start server due to error:.*?EADDRINUSE/,
				);
			});
		});

		it("fails fast if server is started twice", async () => {
			await startAndStopAsync({}, async ({ server }) => {
				await assert.throwsAsync(
					() => startAsync({ server }),
					"Can't start server because it's already running",
				);
			});
		});

		it("fails fast if server is stopped when it isn't running", async () => {
			const { server } = createServer();
			await assert.throwsAsync(
				() => stopAsync({ server }),
				"Can't stop server because it isn't running",
			);
		});

	});


	describe("requests and responses", () => {

		it("runs a function when a request is received and serves the result", async () => {
			const expectedResponse = {
				status: 777,
				headers: {
					header1: "value1",
					header2: "value2",
				},
				body: "my body",
			};

			function onRequestAsync() { return HttpResponse.create(expectedResponse); }

			const { response } = await getAsync({ onRequestAsync });
			assert.deepEqual(response, expectedResponse);
		});

		it("provides request object to request handler", async () => {
			let actualRequest;
			function onRequestAsync(request) {
				actualRequest = request;
			}

			await getAsync({ onRequestAsync });
			assert.instanceOf(actualRequest, HttpRequest);
		});

		it("passes config object through to request handler", async () => {
			let passedThroughConfig;
			function onRequestAsync(request, config) {
				passedThroughConfig = config;
			}

			await getAsync({ onRequestAsync, config: { myConfig: true } });
			assert.deepEqual(passedThroughConfig, { myConfig: true });
		});

		it("logs request (but only method and path, for security)", async () => {
			const { logOutput } = await getAsync({ url: "/my/url?password=abc" });
			assert.deepEqual(logOutput.data, [
				{
					alert: "info",
					message: "request",
					method: "GET",
					url: "/my/url",
				},
			]);
		});

		it("fails gracefully when request handler throws exception", async () => {
			function onRequestAsync() { throw new Error("onRequestAsync error"); }

			const { response, logOutput } = await getAsync({ onRequestAsync });
			assert.deepEqual(logOutput.data.slice(1), [
				{
					alert: Log.EMERGENCY,
					message: "request handler threw exception",
					details: "Error: onRequestAsync error",
				},
			]);
			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			});
		});

		it("fails gracefully when request handler returns invalid response", async () => {
			function onRequestAsync() { return "my invalid response"; }

			const { response, logOutput } = await getAsync({ onRequestAsync });
			assert.deepEqual(logOutput.data.slice(1), [
				{
					alert: Log.EMERGENCY,
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			]);
			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			});
		});

	});


	describe("request simulation", () => {

		it("simulates requests", async () => {
			let requestReceived;
			const responseToSend = HttpResponse.create({
				status: 777,
				headers: { myheader: "myvalue" },
				body: "my body",
			});

			function onRequestAsync(request) {
				requestReceived = request;
				return responseToSend;
			}

			const { request: requestSent, response: responseReceived } = await simulateRequestAsync({ onRequestAsync });

			assert.equal(requestReceived, requestSent, "request");
			assert.deepEqual(responseReceived, responseToSend, "response");
		});

		it("simulating requests fails fast when server isn't running", async () => {
			const server = HttpServer.createNull();
			await assert.throwsAsync(
				() => server.simulateRequestAsync(),
				"Can't simulate request because server isn't running",
			);
		});

		it("returns HttpResponse with debug info when request handler throws exception", async () => {
			const expectedError = new Error("onRequestAsync error");
			function onRequestAsync() { throw expectedError; }

			const { response } = await simulateRequestAsync({ onRequestAsync });
			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler threw exception",
					details: expectedError.stack,
				},
			}));
		});

		it("returns HttpResponse with debug info when handler returns invalid response", async () => {
			function onRequestAsync() { return "my invalid response"; }

			const { response } = await simulateRequestAsync({ onRequestAsync });
			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			}));
		});

	});


	describe("nullability", () => {

		it("doesn't actually start or stop the server", async () => {
			const server = HttpServer.createNull();
			const server2 = HttpServer.createNull();

			await startAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAsync({ server: server2 }),     // fails if server is real because address is already in use
			);
			await stopAsync({ server });
		});

	});

});


async function getAsync({
	onRequestAsync = () => HttpResponse.createForTestingOnly(),
	config,
	url,
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		onRequestAsync: [ undefined, Function ],
		config: [ undefined, Object ],
		url: [ undefined, String ],
	}]]);

	return await startAndStopAsync({ onRequestAsync, config }, async ({ logOutput }) => {
		logOutput.clear();
		return {
			response: await testHelper.requestAsync({ port: PORT, url, method: "GET" }),
			logOutput,
		};
	});
}

async function simulateRequestAsync({
	request = HttpRequest.createNull(),
	onRequestAsync = () => HttpResponse.createForTestingOnly(),
} = {}) {
	const server = HttpServer.createNull();
	await startAsync({ server, onRequestAsync });
	const response = await server.simulateRequestAsync(request);

	return { request, response };
}

async function startAndStopAsync(options, fnAsync = () => {}) {
	const { server, logOutput } = await startAsync(options);
	try {
		return await fnAsync({ logOutput, server });
	}
	finally {
		await stopAsync({ server });
	}
}

async function startAsync({
	server = createServer().server,
	log = Log.createNull(),
	config = { irrelevantConfig: true },
	onRequestAsync = () => {},
} = {}) {
	const logOutput = log.trackOutput();
	await server.startAsync(PORT, log, config, onRequestAsync);
	return { server, logOutput };
}

async function stopAsync({ server }) {
	await server.stopAsync();
}

function createServer() {
	const server = HttpServer.create();
	return { server };
}