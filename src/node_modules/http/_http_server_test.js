// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const ensure = require("util/ensure");
const HttpServer = require("./http_server");
const testHelper = require("util/test_helper");
const HttpRequest = require("./http_request");
const HttpResponse = require("./http_response");
const Log = require("infrastructure/log");

const PORT = 5001;

describe("HTTP Server", () => {

	describe("starting and stopping", () => {

		it("starts and stops server (and can do so multiple times)", async () => {
			const { server } = createServer();

			await startAsync(server);
			await stopAsync(server);
			await startAsync(server);
			await stopAsync(server);
		});

		it("logs server startup", async () => {
			await startAndStopAsync({}, ({ logOutput }) => {
				assert.deepEqual(logOutput.data, [
					{
						alert: "info",
						message: "server started",
						port: PORT,
					},
				]);
			});
		});

		it("says if the server is started", async () => {
			const { server } = createServer();
			assert.equal(server.isStarted, false, "before server started");
			await startAsync(server);
			try {
				assert.equal(server.isStarted, true, "after server started");
			}
			finally {
				await stopAsync(server);
				assert.equal(server.isStarted, false, "after server stopped");
			}
		});

		it("says which port the server is on", async () => {
			const { server } = createServer();
			assert.equal(server.port, null, "before server started");
			await startAsync(server);
			try {
				assert.equal(server.port, PORT, "after server started");
			}
			finally {
				await stopAsync(server);
				assert.equal(server.port, null, "after server stopped");
			}
		});

		it("fails gracefully if server has startup error", async () => {
			await startAndStopAsync({}, async () => {
				const { server } = createServer();
				await assert.throwsAsync(
					() => startAsync(server),     // fails because another server is already running
					/^Couldn't start server due to error:.*?EADDRINUSE/,
				);
			});
		});

		it("fails fast if server is started twice", async () => {
			await startAndStopAsync({}, async ({ server }) => {
				await assert.throwsAsync(
					() => startAsync(server),
					"Can't start server because it's already running",
				);
			});
		});

		it("fails fast if server is stopped when it isn't running", async () => {
			const { server } = createServer();
			await assert.throwsAsync(
				() => stopAsync(server),
				"Can't stop server because it isn't running",
			);
		});

	});


	describe("requests and responses", () => {

		it("runs a function when a request is received and serves the result", async () => {
			const expectedResponse = {
				status: 777,
				headers: {
					header1: "value1",
					header2: "value2",
				},
				body: "my body",
			};

			function onRequestAsync() { return HttpResponse.create(expectedResponse); }

			const { response } = await getAsync({ onRequestAsync });
			assert.deepEqual(response, expectedResponse);
		});

		it("provides request object to request handler", async () => {
			let actualRequest;

			function onRequestAsync(request) {
				actualRequest = request;
			}

			await getAsync({ onRequestAsync });
			assert.instanceOf(actualRequest, HttpRequest);
		});

		it("logs request, but only method and path, for security", async () => {
			const { logOutput } = await getAsync({ url: "/my/url?password=abc", method: "get" });
			assert.deepEqual(logOutput.data, [
				{
					alert: "info",
					message: "request",
					method: "GET",
					url: "/my/url",
				},
			]);
		});

		it("fails gracefully when request handler throws exception", async () => {
			function onRequestAsync() { throw new Error("onRequestAsync error"); }

			const { response, logOutput } = await getAsync({ onRequestAsync });
			assert.deepEqual(logOutput.data.slice(1), [
				{
					alert: Log.EMERGENCY,
					message: "request handler threw exception",
					details: "Error: onRequestAsync error",
				},
			]);
			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			});
		});

		it("fails gracefully when request handler returns invalid response", async () => {
			function onRequestAsync() { return "my invalid response"; }

			const { response, logOutput } = await getAsync({ onRequestAsync });
			assert.deepEqual(logOutput.data.slice(1), [
				{
					alert: Log.EMERGENCY,
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			]);
			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			});
		});

	});


	describe("request simulation", () => {

		it("simulates requests", async () => {
			let actualRequest;
			const expectedResponse = HttpResponse.create({
				status: 777,
				headers: { myheader: "myvalue" },
				body: "my body",
			});

			function onRequestAsync(request) {
				actualRequest = request;
				return expectedResponse;
			}

			const server = HttpServer.createNull();
			await startAsync(server, { onRequestAsync });

			const expectedRequest = HttpRequest.createNull();
			const response = await server.simulateRequestAsync(expectedRequest);

			assert.equal(actualRequest, expectedRequest);
			assert.deepEqual(response, expectedResponse);
		});

		it("simulating requests fails fast when server isn't running", async () => {
			const server = HttpServer.createNull();
			await assert.throwsAsync(
				() => server.simulateRequestAsync(),
				"Can't simulate request because server isn't running",
			);
		});

		it("returns HttpResponse with debug info when request handler throws exception", async () => {
			const expectedError = new Error("onRequestAsync error");

			function onRequestAsync() { throw expectedError; }

			const server = HttpServer.createNull();
			await startAsync(server, { onRequestAsync });
			const request = HttpRequest.createNull();
			const response = await server.simulateRequestAsync(request);

			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler threw exception",
					details: expectedError.stack,
				},
			}));
		});

		it("returns HttpResponse when handler returns invalid response", async () => {
			function onRequestAsync() { return "my invalid response"; }

			const server = HttpServer.createNull();
			await startAsync(server, { onRequestAsync });
			const response = await server.simulateRequestAsync();

			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			}));
		});

	});


	describe("nullability", () => {

		it("doesn't actually start or stop the server", async () => {
			const server = HttpServer.createNull();
			const server2 = HttpServer.createNull();

			await startAsync(server);
			await assert.doesNotThrowAsync(
				() => startAsync(server2),     // fails if server is real because address is already in use
			);
			await stopAsync(server);
		});

	});

});


async function getAsync({
	onRequestAsync = () => HttpResponse.createForTestingOnly(),
	url,
	method,
} = {}) {
	ensure.signature(arguments, [
		[
			undefined, {
			onRequestAsync: [ undefined, Function ],
			url: [ undefined, String ],
			method: [ undefined, String ],
		},
		],
	]);

	return await startAndStopAsync({ onRequestAsync }, async ({ logOutput }) => {
		logOutput.clear();
		return {
			response: await testHelper.requestAsync({ port: PORT, url, method }),
			logOutput,
		};
	});
}

async function startAndStopAsync(options, fnAsync) {
	const { server, log, logOutput } = createServer();
	await startAsync(server, { ...options, log });
	try {
		return await fnAsync({ server, logOutput });
	}
	finally {
		await stopAsync(server);
	}
}

async function startAsync(server, {
	log = Log.createNull(),
	onRequestAsync = () => {},
} = {}) {
	await server.startAsync(PORT, log, onRequestAsync);
}

async function stopAsync(server) {
	await server.stopAsync();
}

function createServer() {
	const log = Log.createNull();
	const server = HttpServer.create();
	return { server, log, logOutput: log.trackOutput() };
}