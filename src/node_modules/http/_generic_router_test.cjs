// Copyright Titanium I.T. LLC.
const assert = require("util/assert");
const ensure = require("util/ensure");
const GenericRouter = require("http/generic_router.cjs");
const HttpRequest = require("http/http_request.cjs");
const Log = require("infrastructure/log");

describe("Generic Router", () => {

	describe("happy paths", () => {

		it("converts an HTTP request into a function call and returns the result", async () => {
			const routes = {
				"/": ExampleController.create(),
			};

			const { response: getResponse } = await routeAsync({ routes, method: "get", url: "/" });
			const { response: postResponse } = await routeAsync({ routes, method: "post", url: "/" });

			assert.equal(getResponse.method, "get");
			assert.equal(postResponse.method, "post");
		});

		it("passes request to route", async () => {
			const { response } = await routeAsync({ url: "/", method: "get" });
			assert.deepEqual(response.request, HttpRequest.createNull({ url: "/", method: "get" }));
		});

		it("passes optional arbitrary config object through to route", async () => {
			const context = { myContextObject: true };

			const { response } = await routeAsync({ url: "/", context });
			assert.equal(response.context, context);
		});

		it("supports multiple paths", async () => {
			const routes = {
				"/one": ExampleController.create("one"),
				"/two/is/a/deep/path": ExampleController.create("two"),
			};

			const { response: oneResponse } = await routeAsync({ routes, url: "/one" });
			const { response: twoResponse } = await routeAsync({ routes, url: "/two/is/a/deep/path" });

			assert.equal(oneResponse.name, "one");
			assert.equal(twoResponse.name, "two");
		});

		it("ignores query strings and fragments", async () => {
			const routes = {
				"/endpoint": ExampleController.create("my_controller"),
			};

			const { response } = await routeAsync({ routes, url: "/endpoint?query=something#fragment" });
			assert.equal(response.name, "my_controller");
		});

	});


	describe("logging", () => {

		it("logs requests", async () => {
			const { logOutput } = await routeAsync({ method: "get", url: "/endpoint" });

			assert.deepEqual(logOutput.data, [{
				alert: "info",
				message: "request",
				method: "get",
				path: "/endpoint",
			}]);
		});

		it("doesn't log queries or fragments (for security)", async () => {
			const { logOutput } = await routeAsync({ routes: "/endpoint", url: "/endpoint?with_query#and_fragment" });
			assert.deepEqual(logOutput.data[0].path, "/endpoint");
		});

	});


	describe("tracking", () => {

		it("tracks requests", async () => {
			const { requests } = await routeAsync({ method: "get", url: "/endpoint" });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

		it("includes context object", async () => {
			const context = { myContext: true };
			const { requests } = await routeAsync({ method: "get", url: "/endpoint", context });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: { myContext: true },
			}]);

		});

		it("normalizes method case", async () => {
			const { requests } = await routeAsync({ method: "GET", url: "/endpoint" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

		it("ignores query strings and fragments", async () => {
			const { requests } = await routeAsync({
				routes: "/endpoint",
				method: "get",
				url: "/endpoint?with_query#and_fragment"
			});

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

	});


	describe("failure paths", () => {

		it("calls error function when path not found", async () => {
			function errorFnAsync(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const { response } = await routeAsync({ routes: [], url: "/no-such-path", method: "get", errorFnAsync });

			assert.deepEqual(response, {
				status: 404,
				errorMessage: "not found",
				request: HttpRequest.createNull({ url: "/no-such-path", method: "get" }),
			});
		});

		it("calls error function when method not defined", async () => {
			function errorFnAsync(status, errorMessage, request) {
				return { status, errorMessage, request };
			}

			const { response } = await routeAsync({ method: "put", url: "/endpoint", errorFnAsync });
			assert.deepEqual(response, {
				status: 405,
				errorMessage: "method not allowed",
				request: HttpRequest.createNull({ url: "/endpoint", method: "put" }),
			});
		});

	});

});

async function routeAsync({
	errorFnAsync = fallbackErrorHandler,
	context = undefined,
	method = "GET",
	url = "/irrelevant_url",
	routes = url,
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		routes: [ undefined, Object, Array, String ],
		errorFnAsync: [ undefined, Function ],
		context: [ undefined, Object ],
		method: [ undefined, String ],
		url: [ undefined, String ],
	}]]);

	const log = Log.createNull();
	const logOutput = log.trackOutput();

	const router = new GenericRouter(errorFnAsync, normalizeRoutes(routes));
	const requests = router.trackRequests();

	const request = HttpRequest.createNull({ method, url });
	const response = await router.routeAsync(request, log, context);

	return { response, requests, logOutput };
}

function normalizeRoutes(routes) {
	if (typeof routes === "string") {
		return { [routes]: ExampleController.create() };
	}
	else if (Array.isArray(routes)) {
		return Object.fromEntries(routes.map(path => [ path, ExampleController.create() ]));
	}
	else {
		return routes;
	}
}

function fallbackErrorHandler(status, message, route) {
	throw new Error(`fallback error handler called: ${JSON.stringify({ status, message, route })}`);
}


class ExampleController {
	static create(controllerName = "irrelevant_controller_name") {
		ensure.signature(arguments, [[ undefined, String ]]);

		return new ExampleController(controllerName);
	}

	constructor(controllerName) {
		ensure.signature(arguments, [ String ]);

		this._name = controllerName;
	}

	async getAsync(request, context) {
		ensure.signature(arguments, [ HttpRequest, [ undefined, Object ]]);

		return { method: "get", request, context, name: this._name };
	}

	async postAsync(request, context) {
		ensure.signature(arguments, [ HttpRequest, [ undefined, Object ]]);

		return { method: "post", request, context, name: this._name };
	}
}
