// Copyright Titanium I.T. LLC.
const assert = require("util/assert");
const ensure = require("util/ensure");
const HttpServer = require("http/http_server");
const testHelper = require("util/test_helper");
const HttpRequest = require("http/http_request.cjs");
const HttpResponse = require("http/http_response.cjs");
const Log = require("infrastructure/log");

const PORT = 5001;

describe("HTTP Server", () => {

	describe("starting and stopping", () => {

		it("can start and stop multiple times", async () => {
			const { server } = createServer();
			await startAndStopAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAndStopAsync({ server })
			);
		});

		it("logs server startup", async () => {
			await startAndStopAsync({}, ({ logOutput }) => {
				assert.deepEqual(logOutput.data, [{
					alert: "info",
					message: "server started",
					port: PORT,
				}]);
			});
		});

		it("says if the server is started", async () => {
			const { server } = createServer();

			assert.equal(server.isStarted, false, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.isStarted, true, "after server started");
			});
			assert.equal(server.isStarted, false, "after server stopped");
		});

		it("says which port the server is on", async () => {
			const { server } = createServer();

			assert.equal(server.port, null, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.port, PORT, "after server started");
			});
			assert.equal(server.port, null, "after server stopped");
		});

		it("fails gracefully if server has startup error", async () => {
			const { server: server1 } = createServer();
			const { server: server2 } = createServer();

			await startAndStopAsync({ server: server1 }, async () => {
				await assert.throwsAsync(
					() => startAsync({ server: server2 }),     // fails because another server is already running
					/^Couldn't start server due to error:.*?EADDRINUSE/,
				);
			});
		});

		it("fails fast if server is started twice", async () => {
			await startAndStopAsync({}, async ({ server }) => {
				await assert.throwsAsync(
					() => startAsync({ server }),
					"Can't start server because it's already running",
				);
			});
		});

		it("fails fast if server is stopped when it isn't running", async () => {
			const { server } = createServer();
			await assert.throwsAsync(
				() => stopAsync({ server }),
				"Can't stop server because it isn't running",
			);
		});

	});


	describe("requests and responses", () => {

		it("runs a routing function when a request is received, then serves the result", async () => {
			const servedResponse = {
				status: 777,
				headers: {
					header1: "value1",
					header2: "value2",
				},
				body: "my body",
			};

			function routeAsync() { return HttpResponse.create(servedResponse); }

			const { response } = await getAsync({ routeAsync });
			assert.deepEqual(response, servedResponse);
		});

		it("provides request object to router", async () => {
			let actualRequest;
			function routeAsync(request) {
				actualRequest = request;
			}

			await getAsync({ routeAsync });
			assert.instanceOf(actualRequest, HttpRequest);
		});

		it("fails gracefully when router throws exception", async () => {
			function routeAsync() { throw new Error("routeAsync error"); }

			const { response, logOutput } = await getAsync({ routeAsync });

			assert.deepEqual(logOutput.data, [{
				alert: Log.EMERGENCY,
				message: "request handler threw exception",
				details: "Error: routeAsync error",
			}], "should log error");

			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			}, "should serve sanitized error");
		});

		it("fails gracefully when router returns invalid response", async () => {
			function routeAsync() { return "my invalid response"; }

			const { response, logOutput } = await getAsync({ routeAsync });

			assert.deepEqual(logOutput.data, [{
				alert: Log.EMERGENCY,
				message: "request handler returned invalid response",
				details: "my invalid response",
			}], "should log error");

			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			}, "should serve sanitized error");
		});

	});


	describe("request simulation", () => {

		it("runs router and returns response that would have been served", async () => {
			const simulatedRequest = HttpRequest.createNull();

			const routerResponse = HttpResponse.create({
				status: 777,
				headers: { myheader: "myvalue" },
				body: "my body",
			});

			let routedRequest;
			function routeAsync(request) {
				routedRequest = request;
				return routerResponse;
			}

			const { response: receivedResponse } = await simulateRequestAsync({ request: simulatedRequest, routeAsync });

			assert.equal(routedRequest, simulatedRequest, "request");
			assert.deepEqual(receivedResponse, routerResponse, "response");
		});

		it("includes debug info in response when router throws exception", async () => {
			const expectedError = new Error("routeAsync error");
			function routeAsync() { throw expectedError; }

			const { response } = await simulateRequestAsync({ routeAsync });
			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler threw exception",
					details: expectedError.stack,
				},
			}));
		});

		it("includes debug info in response when handler returns invalid response", async () => {
			function routeAsync() { return "my invalid response"; }

			const { response } = await simulateRequestAsync({ routeAsync });
			assert.deepEqual(response, HttpResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			}));
		});

		it("simulating requests fails fast when server isn't running", async () => {
			const server = HttpServer.createNull();
			await assert.throwsAsync(
				() => server.simulateRequestAsync(),
				"Can't simulate request because server isn't running",
			);
		});

	});


	describe("nullability", () => {

		it("doesn't actually start or stop the server", async () => {
			const server = HttpServer.createNull();
			const server2 = HttpServer.createNull();

			await startAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAsync({ server: server2 }),     // would fail if server is real because address is already in use
			);
			await stopAsync({ server });
		});

	});

});


async function getAsync({
	routeAsync = () => HttpResponse.createForTestingOnly(),
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		routeAsync: [ undefined, Function ],
	}]]);

	return await startAndStopAsync({ routeAsync }, async ({ logOutput }) => {
		logOutput.clear();
		return {
			response: await testHelper.requestAsync({ port: PORT }),
			logOutput,
		};
	});
}

async function simulateRequestAsync({
	request = HttpRequest.createNull(),
	routeAsync = () => HttpResponse.createForTestingOnly(),
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		request: [ undefined, HttpRequest ],
		routeAsync: [ undefined, Function ],
	}]]);

	const server = HttpServer.createNull();
	await startAsync({ server, routeAsync });
	const response = await server.simulateRequestAsync(request);

	return { response };
}

async function startAndStopAsync(options, fnAsync = () => {}) {
	const { server, logOutput } = await startAsync(options);
	try {
		return await fnAsync({ logOutput, server });
	}
	finally {
		await stopAsync({ server });
	}
}

async function startAsync({
	server = createServer().server,
	routeAsync = () => {},
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		server: [ undefined, HttpServer ],
		routeAsync: [ undefined, Function ],
	}]]);

	const log = Log.createNull();
	const logOutput = log.trackOutput();
	await server.startAsync(PORT, log, { routeAsync });

	return { server, logOutput };
}

async function stopAsync({ server }) {
	ensure.signature(arguments, [{ server: HttpServer }]);

	await server.stopAsync();
}

function createServer() {
	ensure.signature(arguments, []);

	const server = HttpServer.create();
	return { server };
}