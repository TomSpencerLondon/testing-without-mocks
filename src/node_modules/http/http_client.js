// Copyright Titanium I.T. LLC.
"use strict";

const ensure = require("util/ensure");
const http = require("http");
const EventEmitter = require("events");
const OutputTracker = require("util/output_tracker");
const ConfigurableResponses = require("util/configurable_responses");

const REQUEST_EVENT = "request";
const DEFAULT_NULLED_RESPONSE = {
	status: 503,
	headers: { NulledHttpClient: "default header" },
	body: "Nulled HttpClient default body",
	hang: false,
};

/** Generic HTTP client */
module.exports = class HttpClient {

	static create() {
		ensure.signature(arguments, []);

		return new HttpClient(http);
	}

	static createNull(responses) {
		// signature checking in StubbedHttp

		return new HttpClient(new StubbedHttp(responses));
	}

	constructor(http) {
		ensure.signature(arguments, [ Object ]);

		this._http = http;
		this._emitter = new EventEmitter();
	}

	trackRequests() {
		ensure.signature(arguments, []);

		return new OutputTracker(this._emitter, REQUEST_EVENT);
	}

	request({ host, port, method, path, headers = {}, body = "" }) {
		ensure.signature(arguments, [{
			host: String,
			port: Number,
			method: String,
			path: String,
			headers: [ undefined, Object ],
			body: [ undefined, String ],
		}]);
		const requestOptions = {
			host,
			port,
			method: method.toLowerCase(),
			path,
			headers: normalizeHeaders(headers),
			body
		};
		if (requestOptions.method === "get" && requestOptions.body !== "") {
			throw new Error("Don't include body with GET requests; Node won't send it");
		}

		const requestStatus = { inProgress: true };

		const request = this.#sendRequest(requestOptions);
		const cancelFn = this.#createCancelFn(request, requestStatus, requestOptions);

		const responsePromise = new Promise((resolve, reject) => {
			this.#handleResponse(request, requestStatus, resolve);
			this.#handleError(request, reject);
		});

		return { responsePromise, cancelFn };
	}

	#sendRequest(requestOptions) {
		const { body, ...httpOptions } = requestOptions;

		const request = this._http.request(httpOptions);
		request.end(body);
		this._emitter.emit(REQUEST_EVENT, requestOptions);
		return request;
	}

	#createCancelFn(request, requestStatus, requestOptions) {
		return (message) => {
			if (!requestStatus.inProgress) return false;

			request.destroy(new Error(message));
			this._emitter.emit(REQUEST_EVENT, { ...requestOptions, cancelled: true });
			requestStatus.inProgress = false;
			return true;
		};
	}

	#handleResponse(request, requestStatus, resolve) {
		request.once("response", (response) => {
			const headers = { ...response.headers };
			delete headers.connection;
			delete headers["content-length"];
			delete headers.date;

			let body = "";
			response.on("data", (chunk) => {
				body += chunk;
			});
			response.on("end", () => {
				requestStatus.inProgress = false;
				resolve({
					status: response.statusCode,
					headers,
					body,
				});
			});

		});
	}

	#handleError(request, reject) {
		request.once("error", reject);
	}

};

function normalizeHeaders(headers) {
	const normalized = Object.entries(headers).map(([ key, value ]) => [ key.toLowerCase(), value ]);
	return Object.fromEntries(normalized);
}


class StubbedHttp {

	constructor(responses = {}) {
		ensure.signature(responses, [ [ undefined, Object ] ]);

		this._responses = ConfigurableResponses.mapObject(responses, "nulled HTTP client");
	}

	request({ path }) {
		return new NullRequest(path, this._responses[path]);
	}

}

class NullRequest extends EventEmitter {

	constructor(path, endpointResponses = ConfigurableResponses.create(DEFAULT_NULLED_RESPONSE)) {
		super();
		ensure.signature(arguments, [ String, [ undefined, Object, Array ]], [ "endpointResponses" ]);

		this._endpointResponses = endpointResponses;
	}

	end() {
		const response = this._endpointResponses.next();
		setImmediate(() => {
			this.emit("response", new NullResponse(response));
		});
	}

	destroy(error) {
		setImmediate(() => {
			this.emit("error", error);
		});
	}

}

class NullResponse extends EventEmitter {

	constructor({ status = 501, headers = {}, body = "", hang = false }) {
		super();
		ensure.signature(arguments, [{
			status: [ undefined, Number ],
			headers: [ undefined, Object ],
			body: [ undefined, String ],
			hang: [ undefined, Boolean ],
		}], [ "response" ]);

		this._status = status;
		this._headers = normalizeHeaders(headers);

		setImmediate(() => {
			this.emit("data", body);
			if (!hang) this.emit("end");
		});
	}

	get statusCode() {
		return this._status;
	}

	get headers() {
		return this._headers;
	}

}