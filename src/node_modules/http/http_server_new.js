// Copyright Titanium I.T. LLC.
"use strict";

const ensure = require("util/ensure");
const type = require("util/type");
const http = require("http");
const EventEmitter = require("events");
const HttpRequest = require("./http_request");
const HttpResponse = require("./http_response");
const Log = require("infrastructure/log");

/** Wrapper for HTTP server */
module.exports = class HttpServer {

	static create() {
		ensure.signature(arguments, []);
		return new HttpServer(http);
	}

	static createNull() {
		ensure.signature(arguments, []);
		return new HttpServer(nullHttp);
	}

	constructor(http) {
		this._http = http;
		this._handler = null;
	}

	get isStarted() {
		return this._handler !== null;
	}

	get port() {
		return this.isStarted ? this._handler.port : null;
	}

	async startAsync(port, log, requestHandlerFnAsync ) {
		ensure.signature(arguments, [ Number, Log, Function ]);
		if (this.isStarted) throw new Error("Can't start server because it's already running");

		this._handler = await new RequestHandler(this._http, port, log, requestHandlerFnAsync);
		await this._handler.startAsync();
	}

	async stopAsync() {
		ensure.signature(arguments, []);
		if (!this.isStarted) throw new Error("Can't stop server because it isn't running");

		await this._handler.stopAsync();
		this._handler = null;
	}

	async simulateRequestAsync(httpRequest = HttpRequest.createNull()) {
		ensure.signature(arguments, [[ undefined, HttpRequest ]]);
		if (!this.isStarted) throw new Error("Can't simulate request because server isn't running");

		return await this._handler.simulateRequestAsync(httpRequest);
	}

};


class RequestHandler {
	constructor(http, port, log, requestHandlerFnAsync) {
		this._nodeServer = http.createServer();
		this._port = port;
		this._log = log;
		this._requestHandlerFnAsync = requestHandlerFnAsync;
	}

	get port() {
		return this._port;
	}

	async startAsync() {
		await new Promise((resolve, reject) => {
			this._nodeServer.on("listening", () => {
				logServerStart(this._log, this._port);
				resolve();
			});
			this._nodeServer.on("error", (err) => {
				reject(new Error(`Couldn't start server due to error: ${err.message}`));
			});
			this._nodeServer.on("request", async (nodeRequest, nodeResponse) => {
				const response = await handleRequestAsync(
					this._log, HttpRequest.create(nodeRequest), this._requestHandlerFnAsync
				);
				sendResponse(nodeResponse, response);
			});
			return this._nodeServer.listen(this._port);
		});
	}

	async stopAsync() {
		await new Promise((resolve, reject) => {
			this._nodeServer.on("close", () => resolve());
			this._nodeServer.close();
		});
	}

	async simulateRequestAsync(httpRequest) {
		return await handleRequestAsync(this._log, httpRequest, this._requestHandlerFnAsync);
	}

}


async function handleRequestAsync(log, httpRequest, requestHandlerFnAsync) {
	try {
		logRequest(log, httpRequest.method, httpRequest.urlPathname);
		const response = await requestHandlerFnAsync(httpRequest);
		const typeError = type.check(response, HttpResponse);
		if (typeError !== null) {
			return internalServerError(log, response, "request handler returned invalid response");
		}
		else {
			return response;
		}
	}
	catch (err) {
		return internalServerError(log, err, "request handler threw exception");
	}
}

function sendResponse(nodeResponse, response) {
	nodeResponse.statusCode = response.status;
	Object.entries(response.headers).forEach(([name, value]) => nodeResponse.setHeader(name, value));
	nodeResponse.end(response.body);
}

function internalServerError(log, details, message) {
	log.emergency({ message, details });
	return HttpResponse.createPlainTextResponse({
		status: 500,
		body: "Internal Server Error",
		debug: {
			message,
			details: details instanceof Error ? details.stack : details,
		},
	});
}

function logServerStart(log, port) {
	log.info({
		message: "server started",
		port,
	});
}

function logRequest(log, method, url) {
	log.info({
		message: "request",
		method,
		url,
	});
}


const nullHttp = {
	createServer() {
		return new NullNodeServer();
	}
};

class NullNodeServer extends EventEmitter {
	listen() {
		setImmediate(() => this.emit("listening"));
	}
	close() {
		setImmediate(() => this.emit("close"));
	}
}