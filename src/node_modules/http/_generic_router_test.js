// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const ensure = require("util/ensure");
const GenericRouter = require("./generic_router");
const HttpRequest = require("./http_request");
const Log = require("infrastructure/log");

describe("Generic Router", () => {

	describe("happy paths", () => {

		it("converts an HTTP request into a function call and returns the result", async () => {
			const router = createRouter({
				"/": {
					getAsync() { return "get called"; },
					postAsync() { return "post called"; },
				},
			});

			assert.equal((await routeAsync(router, { method: "get", url: "/" })).response, "get called");
			assert.equal((await routeAsync(router, { method: "post", url: "/" })).response, "post called");
		});

		it("passes request to route", async () => {
			const router = createRouter({
				"/": {
					getAsync(request) { return request; }
				},
			});
			const request = HttpRequest.createNull({ method: "get", url: "/" });

			const { response } = await routeAsync(router, { request });
			assert.deepEqual(response, request);
		});

		it("passes optional arbitrary config object through to route", async () => {
			const router = createRouter({
				"/": {
					getAsync(request, config) { return config; }
				},
			});
			const config = { myArbitraryConfig: true };

			const { response } = await routeAsync(router, { method: "get", url: "/", config });
			assert.equal(response, config);
		});

		it("supports multiple paths", async () => {
			const router = createRouter({
				"/one": {
					getAsync() { return "one called"; },
				},
				"/two/is/a/deep/path": {
					getAsync() { return "two called"; },
				},
			});

			assert.equal((await routeAsync(router, { method: "get", url: "/one" })).response, "one called");
			assert.equal((await routeAsync(router, { method: "get", url: "/two/is/a/deep/path" })).response, "two called");
		});

		it("ignores query strings and fragments", async () => {
			const router = createRouter({
				"/my_url": {
					getAsync() { return "get called"; }
				},
			});

			const { response } = await routeAsync(router, { method: "get", url: "/my_url?query=something#fragment" });
			assert.equal(response, "get called");
		});

	});


	describe("logging", () => {

		it("logs requests", async () => {
			const router = createRouter({
				"/": {
					getAsync() {},
				},
			});

			const { logOutput } = await routeAsync(router, { method: "get", url: "/" });
			assert.deepEqual(logOutput.data, [{
				alert: "info",
				message: "request",
				method: "get",
				path: "/",
			}]);
		});

		it("doesn't log queries or fragments (for security)", async () => {
			const router = createRouter({
				"/endpoint": {
					getAsync() {},
				},
			});

			const { logOutput } = await routeAsync(router, { method: "get", url: "/endpoint?with_query#and_fragment" });
			assert.deepEqual(logOutput.data[0].path, "/endpoint");
		});

	});


	describe("tracking", () => {

		it("tracks requests", async () => {
			const { router, requests } = trackRequests({ paths: [ "/one", "/two" ]});

			await routeAsync(router, { method: "get", url: "/one" });
			await routeAsync(router, { method: "post", url: "/two" });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/one",
				config: undefined,
			}, {
				method: "post",
				path: "/two",
				config: undefined,
			}]);
		});

		it("includes config object", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});
			const config = { myConfig: true };

			await routeAsync(router, { method: "get", url: "/endpoint", config });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: { myConfig: true },
			}]);

		});

		it("normalizes method case", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});

			await routeAsync(router, { method: "GET", url: "/endpoint" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: undefined,
			}]);
		});

		it("ignores query strings and fragments", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});

			await routeAsync(router, { method: "get", url: "/endpoint?with_query#and_fragment" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: undefined,
			}]);
		});

	});


	describe("failure paths", () => {

		it("calls error function when path not found", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({}, errorHandler);

			const request = HttpRequest.createNull({ url: "/no-such-path" });
			const { response } = await routeAsync(router, { request });
			assert.deepEqual(response, {
				status: 404,
				errorMessage: "not found",
				request,
			});
		});

		it("calls error function when method not defined", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({
				"/": {}
			}, errorHandler);

			const request = HttpRequest.createNull({ method: "get", url: "/" });
			const { response } = await routeAsync(router, { request });
			assert.deepEqual(response, {
				status: 405,
				errorMessage: "method not allowed",
				request,
			});
		});

	});

});


function createRouter(routes, errorFnAsync = fallbackErrorHandler) {
	ensure.signature(arguments, [ Object, [ undefined, Function ]]);

	return GenericRouter.create(errorFnAsync, routes);
}

async function routeAsync(router, options = {}) {
	ensure.signatureMinimum(arguments, [ GenericRouter, [ undefined, {
		config: [ undefined, Object ],
		request: [ undefined, HttpRequest ],
	}]]);

	let { config, request, ...requestOptions } = options;

	request = request ?? HttpRequest.createNull(requestOptions);
	const log = Log.createNull();
	const logOutput = log.trackOutput();
	const response = await router.routeAsync(request, log, config);

	return { response, logOutput };
}

function trackRequests({
	paths = [],
} = {}) {
	ensure.signature(arguments, [ Object, [ undefined, {
		paths: [ undefined, Array ],
	}]]);

	const routes = Object.fromEntries(paths.map(path => [ path, new ExampleController() ]));
	const router = createRouter(routes);
	const requests = router.trackRequests();

	return { router, requests };
}

function fallbackErrorHandler(status, message, route) {
	throw new Error(`fallback error handler called: ${JSON.stringify({ status, message, route })}`);
}


class ExampleController {
	getAsync() {
		return "irrelevant get response";
	}

	postAsync() {
		return "irrelevant post response";
	}
}