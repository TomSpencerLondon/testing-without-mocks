// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const ensure = require("util/ensure");
const GenericRouter = require("./generic_router");
const HttpRequest = require("./http_request");

describe("Generic Router", () => {

	describe("happy paths", () => {

		it("converts an HTTP request into a function call and returns the result", async () => {
			const router = createRouter({
				"/": {
					getAsync() { return "get called"; },
					postAsync() { return "post called"; },
				},
			});

			assert.equal(await routeAsync(router, { method: "get", url: "/" }), "get called");
			assert.equal(await routeAsync(router, { method: "post", url: "/" }), "post called");
		});

		it("passes request to route", async () => {
			const router = createRouter({
				"/": {
					getAsync(request) { return request; }
				},
			});
			const request = HttpRequest.createNull({ method: "get", url: "/" });

			assert.equal(await router.routeAsync(request), request);
		});

		it("passes optional arbitrary config object through to route", async () => {
			const router = createRouter({
				"/": {
					getAsync(request, config) { return config; }
				},
			});
			const config = { myArbitraryConfig: true };

			const actualConfig = await routeAsync(router, { method: "get", url: "/", config });
			assert.equal(actualConfig, config);
		});

		it("supports multiple paths", async () => {
			const router = createRouter({
				"/one": {
					getAsync() { return "one called"; },
				},
				"/two/is/a/deep/path": {
					getAsync() { return "two called"; },
				},
			});

			assert.equal(await routeAsync(router, { method: "get", url: "/one" }), "one called");
			assert.equal(await routeAsync(router, { method: "get", url: "/two/is/a/deep/path" }), "two called");
		});

		it("ignores query strings and fragments", async () => {
			const router = createRouter({
				"/my_url": {
					getAsync() { return "get called"; }
				},
			});

			assert.equal(
				await routeAsync(router, { method: "get", url: "/my_url?query=something#fragment" }),
				"get called"
			);
		});

	});


	describe("tracking", () => {

		it("tracks requests", async () => {
			const { router, requests } = trackRequests({ paths: [ "/one", "/two" ]});

			await routeAsync(router, { method: "get", url: "/one" });
			await routeAsync(router, { method: "post", url: "/two" });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/one",
				config: undefined,
			}, {
				method: "post",
				path: "/two",
				config: undefined,
			}]);
		});

		it("includes config object", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});
			const config = { myConfig: true };

			await routeAsync(router, { method: "get", url: "/endpoint", config });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: { myConfig: true },
			}]);

		});

		it("normalizes method case", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});

			await routeAsync(router, { method: "GET", url: "/endpoint" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: undefined,
			}]);
		});

		it("ignores query strings and fragments", async () => {
			const { router, requests } = trackRequests({ paths: [ "/endpoint" ]});

			await routeAsync(router, { method: "get", url: "/endpoint?with_query#and_fragment" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				config: undefined,
			}]);
		});

	});


	describe("failure paths", () => {

		it("calls error function when path not found", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({}, errorHandler);

			const request = HttpRequest.createNull({ url: "/anything" });
			assert.deepEqual(await router.routeAsync(request), {
				status: 404,
				errorMessage: "not found",
				request,
			});
		});

		it("calls error function when method not defined", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({
				"/": {}
			}, errorHandler);

			const request = HttpRequest.createNull({ method: "get", url: "/" });
			assert.deepEqual(await router.routeAsync(request), {
				status: 405,
				errorMessage: "method not allowed",
				request,
			});
		});

	});

});


function createRouter(routes, errorFnAsync = fallbackErrorHandler) {
	ensure.signature(arguments, [ Object, [ undefined, Function ]]);

	return GenericRouter.create(errorFnAsync, routes);
}

async function routeAsync(router, options) {
	ensure.signature(arguments, [ GenericRouter, Object ]);

	const { config, ...requestOptions } = options;

	const request = HttpRequest.createNull(requestOptions);
	return await router.routeAsync(request, config);
}

function trackRequests({
	paths = [],
} = {}) {
	ensure.signature(arguments, [ Object, [ undefined, {
		paths: [ undefined, Array ],
	}]]);

	const routes = Object.fromEntries(paths.map(path => [ path, new ExampleController() ]));
	const router = createRouter(routes);
	const requests = router.trackRequests();

	return { router, requests };
}

function fallbackErrorHandler(status, message, route) {
	throw new Error(`fallback error handler called: ${JSON.stringify({ status, message, route })}`);
}


class ExampleController {
	getAsync() {
		return "irrelevant get response";
	}

	postAsync() {
		return "irrelevant post response";
	}
}